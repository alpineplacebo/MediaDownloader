import yt_dlp
from PyQt6.QtCore import QObject, pyqtSignal, QThread
from pathlib import Path
import os
import re
import sys

def get_ffmpeg_path():
    if getattr(sys, 'frozen', False):
        return sys._MEIPASS
    return None

class YtDlpWorker(QObject):
    """
    Worker class to handle yt-dlp operations in a separate thread.
    """
    finished = pyqtSignal()
    progress = pyqtSignal(dict)
    info_ready = pyqtSignal(dict)
    error_occurred = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self._is_running = False
        self._cancel_requested = False
        self._current_filename = None

    def trigger_cancel(self):
        """Sets the cancellation flag."""
        self._cancel_requested = True
    
    def fetch_info(self, url, cookies_browser=None):
        """Fetch video information without downloading."""
        try:
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'skip_download': True,
                'noplaylist': True,
            }
            if cookies_browser and cookies_browser != "None":
                ydl_opts['cookiesfrombrowser'] = (cookies_browser,)

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                self.info_ready.emit(info)
        except Exception as e:
            self.error_occurred.emit(str(e))

    def download(self, url, opts=None, cookies_browser=None):
        """Download video with given options."""
        self._cancel_requested = False
        self._current_filename = None

        if opts is None:
            opts = {}

        # Capture the intended paths (home) to verify file existence in correct dir
        download_dir = Path(opts.get('paths', {}).get('home', os.getcwd()))

        def avoid_collision(info_dict, default_filename_func):
            """
            Hook to modify filename if it exists.
            Generates 'filename (1).ext' pattern.
            """
            # Get the default filename generated by yt-dlp
            filename = default_filename_func(info_dict)
            base_path = Path(filename)
            
            if not base_path.exists():
                return filename

            # File exists, find a unique name
            folder = base_path.parent
            stem = base_path.stem
            suffix = base_path.suffix
            
            counter = 1
            while True:
                new_stem = f"{stem} ({counter})"
                new_filename = folder / (new_stem + suffix)
                if not new_filename.exists():
                    return str(new_filename)
                counter += 1

        ydl_opts = {
            'quiet': True,
            'no_warnings': True,
            'progress_hooks': [self._progress_hook],
            'outtmpl': '%(title)s.%(ext)s',
            # 'prepare_filename': ... # Will inject this manually
        }

        if cookies_browser and cookies_browser != "None":
            ydl_opts['cookiesfrombrowser'] = (cookies_browser,)

        ffmpeg_path = get_ffmpeg_path()
        if ffmpeg_path:
            ydl_opts['ffmpeg_location'] = ffmpeg_path

        ydl_opts.update(opts)

        try:
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                original_prepare_filename = ydl.prepare_filename
                
                def collision_avoidance_wrapper(info, *args, **kwargs):
                    path_str = original_prepare_filename(info, *args, **kwargs)
                    path = Path(path_str)
                    
                    if not path.exists():
                        return path_str
                    
                    # Conflict
                    parent = path.parent
                    stem = path.stem
                    suffix = path.suffix
                    
                    counter = 1
                    while True:
                        new_path = parent / f"{stem} ({counter}){suffix}"
                        if not new_path.exists():
                            return str(new_path)
                        counter += 1
                
                ydl.prepare_filename = collision_avoidance_wrapper
                
                ydl.download([url])
            self.finished.emit()
        except Exception as e:
            msg = str(e)
            if "DOWNLOAD_CANCELLED" in msg:
                # Clean up incomplete files
                if self._current_filename:
                    import time
                    import glob

                    # Give yt-dlp a moment to release handles
                    time.sleep(0.5)

                    try:
                        file_path = Path(self._current_filename)
                        if not file_path.is_absolute():
                            file_path = download_dir / file_path
                        
                        # Find all related files (including fragments) using glob
                        folder = file_path.parent
                        name_pattern = file_path.name + "*"
                        
                        candidates = []
                        if folder.exists():
                           candidates = list(folder.glob(name_pattern))

                        if file_path not in candidates:
                            candidates.append(file_path)

                        for path in candidates:
                            if path.exists():
                                for _ in range(3):
                                    try:
                                        os.remove(path)
                                        break # Success
                                    except PermissionError:
                                        time.sleep(0.5) 
                                    except OSError:
                                        break 
                    except Exception:
                        pass
                
                self.error_occurred.emit("Download cancelled.")
            else:
                self.error_occurred.emit(str(e))

    def _progress_hook(self, d):
        """Internal hook to emit progress signal."""
        if self._cancel_requested:
            raise Exception("DOWNLOAD_CANCELLED")

        self._current_filename = d.get('filename')

        if d['status'] == 'downloading':
            p_dict = {
                'status': 'downloading',
                'filename': d.get('filename', 'Unknown'),
                'downloaded_bytes': d.get('downloaded_bytes', 0),
                'total_bytes': d.get('total_bytes') or d.get('total_bytes_estimate', 0),
                'speed': d.get('speed', 0),
                'eta': d.get('eta', 0),
                'percent': d.get('_percent_str', '0%').replace('%','')
            }
            self.progress.emit(p_dict)
        elif d['status'] == 'finished':
            self.progress.emit({'status': 'finished', 'filename': d['filename']})

class DownloaderThread(QThread):
    def __init__(self):
        super().__init__()
        self.worker = YtDlpWorker()
        self.worker.moveToThread(self)
    
    def run(self):
        self.exec()
